ğŸ›¡ï¸ SYSTEM MANDATE: THE SLOPCHOP PROTOCOL
ROLE: High-Integrity Systems Architect (NASA/JPL Standard).
CONTEXT: You are coding inside a strict environment enforced by SlopChop.

THE 3 LAWS (Non-Negotiable):

1. LAW OF ATOMICITY
   - Files: MUST be < 2000 tokens.
   - Action: Split immediately if larger.

2. LAW OF COMPLEXITY
   - Cyclomatic Complexity: MUST be â‰¤ 8 per function.
   - Nesting Depth: MUST be â‰¤ 3 levels.
   - Function Arguments: MUST be â‰¤ 5 parameters.

3. LAW OF PARANOIA
   - Use Result<T, E> for I/O and fallible operations.
   - NO .unwrap() or .expect() calls.

CONTEXT STRATEGY (How to drive):

1. IF you receive 'SIGNATURES.txt' (The Map):
   - You are in ARCHITECT MODE.
   - Do NOT write code yet.
   - Analyze the map to locate the specific files relevant to the user's request.
   - INSTRUCT the user to pack those files:
     'Please run: slopchop pack src/foo.rs src/bar.rs --copy'

2. IF you receive 'context.txt' (Source Code):
   - You are in DEVELOPER MODE.
   - You have the implementation details.
   - PROCEED to write the solution using the Output Format below.

OUTPUT FORMAT (MANDATORY):

1. Explain the changes (Technical Plan):
   - Must start with "GOAL:"
   - Must include "CHANGES:" list

#__SLOPCHOP_PLAN__#
GOAL: Refactor authentication module.
CHANGES:
1. Extract user validation to new file.
2. Update config parser.
#__SLOPCHOP_END__#

2. Declare the plan (Manifest):

#__SLOPCHOP_MANIFEST__#
path/to/file1.rs
path/to/file2.rs [NEW]
#__SLOPCHOP_END__#

3. Provide EACH file:

#__SLOPCHOP_FILE__# path/to/file1.rs
[file content]
#__SLOPCHOP_END__#

4. Update the Roadmap (ask yourself: did you do something that matters to the project plan? Record it.):
   - Use this block if you completed a task or need to add one.

===ROADMAP===
CHECK
id = task-id
ADD
id = new-task
text = Refactor logs
section = v0.2.0
===ROADMAP===

RULES:
- Do NOT use markdown code blocks (e.g. triple backticks) to wrap the file. The #__SLOPCHOP_FILE__# delimiters ARE the fence.
- You MAY use markdown inside the file content.
- Every file in the manifest MUST have a matching #__SLOPCHOP_FILE__# block.
- Paths must match exactly.
- Do NOT truncate files (No "// ...").


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BEGIN CODEBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#__SLOPCHOP_FILE__# Cargo.toml
[package]
name = "git-trek"
version = "2.2.0"
edition = "2021"
authors = ["Spencer Nunamaker <junovhs@gmail.com>"]
description = "ğŸš€ Navigate git history like it's 1989!"
homepage = "https://github.com/junovhs/git-trek"
repository = "https://github.com/junovhs/git-trek"
license = "MIT"
readme = "README.md"
keywords = ["git", "cli", "tui", "navigation", "history"]
categories = ["command-line-utilities", "development-tools"]

[[bin]]
name = "git-trek"
path = "src/main.rs"

[dependencies]
anyhow = "1.0"
clap = { version = "4.5", features = ["derive"] }
crossterm = "0.28"
git2 = "0.19"
ratatui = "0.29"
chrono = "0.4"

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.10"

[profile.release]
lto = true
codegen-units = 1
strip = true
opt-level = "z"

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# README.md
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—    â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•    â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â•‘
â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—     â•‘
â•‘  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—    â•‘
â•‘   â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•         â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•    â•‘
â•‘                                                               â•‘
â•‘              Visual Git Time Travel & File Recovery           â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

> *"When did this file get fucked?"* â€” Every developer, eventually

**git-trek** is a visual file health monitor for git. See your entire codebase as a treemap, scrub through time with your mouse, and instantly spot when files got truncated, deleted, or corrupted. One click to restore.

## The Problem

You're coding. Something breaks. A file got truncated, filled with junk, or mysteriously emptied. Now you need to:
1. Figure out *when* it broke
2. Find what it looked like *before*
3. Restore it

The git CLI way: `git log --oneline -- file`, squint at hashes, `git show abc123:file`, copy-paste... painful.

**git-trek way**: Scroll wheel to scrub time. Red = maybe fucked. Click. Restore. Done.

## Installation

```bash
# Clone and build
git clone https://github.com/junovhs/git-trek.git
cd git-trek
cargo install --path .

# Or just run it
cargo run --release
```

Requires Rust toolchain: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`

## Usage

```bash
# In any git repo
git-trek

# Load more history
git-trek --limit 500
```

## The Interface

```
â”Œâ”€ GIT-TREK v3.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [1] Treemap  [2] Heatmap  [3] Minimap  [4] River  [5] Focus     â”‚
â”œâ”€ 42 / 100 â”‚ fix: restore deleted function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”œâ”€ Files @ a1b2c3d4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚â”‚                      â”‚â”‚        â”‚â”‚   ğŸ”´   â”‚â”‚      â”‚â”‚           â”‚â”‚
â”‚â”‚    src/app.rs        â”‚â”‚main.rs â”‚â”‚lib.rs  â”‚â”‚cli.rsâ”‚â”‚ tests/    â”‚â”‚
â”‚â”‚      152 ln          â”‚â”‚ 89 ln  â”‚â”‚ 12 ln  â”‚â”‚45 ln â”‚â”‚           â”‚â”‚
â”‚â”‚                      â”‚â”‚        â”‚â”‚        â”‚â”‚      â”‚â”‚           â”‚â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [click] select | [scroll] time travel | [R] restore | [Q] quit  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Rectangle size** = file size (lines of code)
**Color** = health status:
- â¬› Gray: Stable, no significant change
- ğŸŸ¢ Green: File grew
- ğŸŸ¡ Yellow: File shrank slightly  
- ğŸ”´ Red: **File shrank >30%** â€” probably fucked
- ğŸ”µ Blue: New file

## Controls

| Input | Action |
|-------|--------|
| **Scroll wheel** | Scrub through commits |
| **â† â†’** | Navigate timeline |
| **Click file** | Select for restore |
| **Hover** | Highlight file (magenta) |
| **R** | Restore selected file from current commit |
| **1-5** | Switch view modes |
| **Tab** | Cycle views |
| **Esc** | Deselect |
| **Q** | Quit |

## View Modes

| Mode | Purpose | Status |
|------|---------|--------|
| **[1] Treemap** | WinDirStat-style overview | âœ… Working |
| **[2] Heatmap** | Activity over time | ğŸš§ Coming |
| **[3] Minimap** | Code shape comparison | ğŸš§ Coming |
| **[4] River** | File size evolution | ğŸš§ Coming |
| **[5] Focus** | Deep dive on one file | ğŸš§ Coming |

## How It Works

1. **Loads your git history** â€” walks commits, records file sizes at each point
2. **Builds a treemap** â€” files sized proportionally to line count
3. **Tracks health** â€” compares each commit to its parent, flags suspicious changes
4. **Mouse-driven navigation** â€” scroll to time travel, click to select, R to restore

No branches created. No working directory changes. Pure read-only inspection until you explicitly restore.

## When To Use It

- **"Something broke, when?"** â€” Scroll back, watch for red
- **"What did this file look like before?"** â€” Navigate to commit, click file, R to restore
- **"Overview of my codebase"** â€” Treemap shows relative file sizes instantly
- **"Which files change together?"** â€” Scrub time, watch the colors shift

## Options

```bash
git-trek --limit 200    # Load 200 commits (default: 100)
git-trek --help         # Show help
```

## Requirements

- Git repository
- Terminal with mouse support (most modern terminals)
- Rust toolchain (for building)

## Development

```bash
cargo run              # Debug build
cargo run --release    # Fast build  
cargo test             # Run tests
cargo clippy           # Lint
```

## Roadmap

- [x] Treemap view with health coloring
- [x] Mouse hover/click/scroll
- [x] File restore from any commit
- [ ] Heatmap view (activity over time)
- [ ] Minimap view (code shape diff)
- [ ] River view (size evolution)
- [ ] Focus view (single file deep dive)
- [ ] Sparklines per file
- [ ] Filter by path/extension
- [ ] Search commits

---

*Built for developers who think visually and hate typing `git log`.*
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# slopchop.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = [
    "tests",
    "spec",
]
ignore_tokens_on = [
    "README.md",
    "lock",
]

[preferences]
theme = "Cyberpunk"
auto_copy = true
auto_format = false
auto_commit = false
commit_prefix = "AI: "
allow_dirty_git = false
system_bell = false
backup_retention = 5
progress_bars = true
require_plan = false

[commands]
check = [
    "cargo clippy --all-targets -- -D warnings -W clippy::pedantic",
    "cargo test",
]
fix = ["cargo fmt"]

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/app.rs
use anyhow::Result;
use git2::Repository;

use crate::{
    cli::Cli,
    data::{HealthStatus, RepoData},
    git_ops,
    mouse::{HitId, MouseState},
    views::ViewMode,
};

pub struct App {
    pub repo: Repository,
    pub data: RepoData,
    pub view: ViewMode,
    pub commit_idx: usize,
    pub selected_file: Option<String>,
    pub mouse: MouseState,
    pub should_quit: bool,
    pub message: Option<String>,
}

impl App {
    pub fn new(cli: &Cli) -> Result<Self> {
        let repo = Repository::open_from_env()?;
        let data = git_ops::load_repo_data(&repo, cli.limit)?;

        Ok(Self {
            repo,
            data,
            view: ViewMode::default(),
            commit_idx: 0,
            selected_file: None,
            mouse: MouseState::default(),
            should_quit: false,
            message: None,
        })
    }

    pub fn current_commit_label(&self) -> String {
        self.data.commits.get(self.commit_idx)
            .map_or_else(|| "---".to_string(), |c| git_ops::format_oid(c.oid))
    }

    pub fn files_at_current_commit(&self) -> Vec<(String, usize)> {
        let mut files: Vec<_> = self.data.files.iter()
            .filter_map(|(path, tracked)| {
                tracked.lines_at(self.commit_idx).map(|lines| (path.clone(), lines))
            })
            .collect();
        files.sort_by(|a, b| b.1.cmp(&a.1));
        files
    }

    pub fn file_health(&self, path: &str) -> HealthStatus {
        let prev_idx = if self.commit_idx + 1 < self.data.commits.len() {
            Some(self.commit_idx + 1)
        } else {
            None
        };
        self.data.files.get(path)
            .map_or(HealthStatus::Stable, |f| f.health_at(self.commit_idx, prev_idx))
    }

    pub fn handle_click(&mut self, id: HitId) {
        match id {
            HitId::File(path) => { self.selected_file = Some(path); }
            HitId::ViewTab(i) => { self.view = ViewMode::from_index(i); }
            HitId::None => {}
        }
    }

    pub fn scroll_timeline(&mut self, delta: isize) {
        let max = self.data.commits.len().saturating_sub(1);
        let abs_delta = delta.unsigned_abs();
        let new_idx = if delta > 0 {
            self.commit_idx.saturating_add(abs_delta)
        } else {
            self.commit_idx.saturating_sub(abs_delta)
        };
        self.commit_idx = new_idx.min(max);
    }

    pub fn set_view(&mut self, mode: ViewMode) { self.view = mode; }
    pub fn next_view(&mut self) { self.view = self.view.next(); }
    pub fn prev_view(&mut self) { self.view = self.view.prev(); }

    pub fn restore_selected(&mut self) -> Result<()> {
        let Some(path) = &self.selected_file else { return Ok(()); };
        let oid = self.data.commits[self.commit_idx].oid;
        git_ops::restore_file(&self.repo, oid, path)?;
        self.message = Some(format!("Restored {path} from {}", git_ops::format_oid(oid)));
        Ok(())
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/cli.rs
use anyhow::{anyhow, Result};
use clap::Parser;

#[derive(Parser, Debug, Clone)]
#[command(name = "git-trek", about = "Navigate git history like it's 1989", version)]
struct CliRaw {
    #[arg(long, default_value_t = 200)]
    pub limit: usize,
    #[arg(long, hide = true)]
    pub dry_run: bool,
}

#[derive(Debug, Clone)]
pub struct Cli {
    pub limit: usize,
    pub dry_run: bool,
}

impl Cli {
    pub fn parse_checked() -> Result<Self> {
        let raw = <CliRaw as Parser>::parse();
        if raw.limit == 0 {
            return Err(anyhow!("--limit must be > 0"));
        }
        Ok(Self {
            limit: raw.limit,
            dry_run: raw.dry_run,
        })
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/data.rs
use git2::Oid;
use std::collections::HashMap;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum HealthStatus {
    Stable,
    Grew,
    Shrank,
    MaybeFucked,
    New,
    Deleted,
}

impl HealthStatus {
    pub fn from_size_change(old: Option<usize>, new: Option<usize>) -> Self {
        match (old, new) {
            (None, None) => Self::Stable,
            (None, Some(_)) => Self::New,
            (Some(_), None) => Self::Deleted,
            (Some(o), Some(n)) => Self::from_ratio(o, n),
        }
    }

    #[allow(clippy::cast_precision_loss)]
    fn from_ratio(old: usize, new: usize) -> Self {
        if old == 0 { return Self::New; }
        let ratio = new as f64 / old as f64;
        if ratio < 0.7 { Self::MaybeFucked }
        else if ratio < 0.95 { Self::Shrank }
        else if ratio > 1.05 { Self::Grew }
        else { Self::Stable }
    }
}

#[derive(Clone, Debug)]
pub struct FileSnapshot {
    pub lines: usize,
    #[allow(dead_code)]
    pub bytes: usize,
}

#[derive(Clone, Debug)]
pub struct TrackedFile {
    #[allow(dead_code)]
    pub path: String,
    pub history: HashMap<usize, FileSnapshot>,
}

impl TrackedFile {
    pub fn new(path: String) -> Self {
        Self { path, history: HashMap::new() }
    }

    pub fn lines_at(&self, commit_idx: usize) -> Option<usize> {
        self.history.get(&commit_idx).map(|s| s.lines)
    }

    pub fn health_at(&self, commit_idx: usize, prev_idx: Option<usize>) -> HealthStatus {
        let new_lines = self.lines_at(commit_idx);
        let old_lines = prev_idx.and_then(|i| self.lines_at(i));
        HealthStatus::from_size_change(old_lines, new_lines)
    }
}

#[derive(Clone, Debug)]
pub struct CommitInfo {
    pub oid: Oid,
    pub summary: String,
    #[allow(dead_code)]
    pub author: String,
    #[allow(dead_code)]
    pub timestamp: i64,
    #[allow(dead_code)]
    pub files_changed: Vec<String>,
    #[allow(dead_code)]
    pub insertions: usize,
    #[allow(dead_code)]
    pub deletions: usize,
}

#[derive(Clone, Default)]
pub struct RepoData {
    pub commits: Vec<CommitInfo>,
    pub files: HashMap<String, TrackedFile>,
}

impl RepoData {
    pub fn new() -> Self { Self::default() }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/git_ops.rs
use anyhow::{Context, Result};
use git2::{Oid, Repository, Sort, Tree};

use crate::data::{CommitInfo, FileSnapshot, RepoData, TrackedFile};

pub fn load_repo_data(repo: &Repository, limit: usize) -> Result<RepoData> {
    let mut data = RepoData::new();
    let oids = collect_commit_oids(repo, limit)?;

    for (idx, oid) in oids.iter().enumerate() {
        let commit = repo.find_commit(*oid)?;
        let info = build_commit_info(repo, &commit)?;
        collect_file_snapshots(repo, &commit.tree()?, idx, &mut data.files)?;
        data.commits.push(info);
    }
    Ok(data)
}

fn collect_commit_oids(repo: &Repository, limit: usize) -> Result<Vec<Oid>> {
    let mut revwalk = repo.revwalk()?;
    revwalk.push_head()?;
    revwalk.set_sorting(Sort::TOPOLOGICAL | Sort::TIME)?;
    Ok(revwalk.filter_map(Result::ok).take(limit).collect())
}

fn build_commit_info(repo: &Repository, commit: &git2::Commit) -> Result<CommitInfo> {
    let author_str = commit.author().to_string();
    let summary_str = commit.summary().unwrap_or("").to_string();
    let (insertions, deletions) = get_diff_stats(repo, commit)?;

    Ok(CommitInfo {
        oid: commit.id(),
        summary: summary_str,
        author: author_str,
        timestamp: commit.time().seconds(),
        files_changed: Vec::new(),
        insertions,
        deletions,
    })
}

fn get_diff_stats(repo: &Repository, commit: &git2::Commit) -> Result<(usize, usize)> {
    if commit.parent_count() == 0 {
        return Ok((0, 0));
    }
    let parent = commit.parent(0)?;
    let diff = repo.diff_tree_to_tree(Some(&parent.tree()?), Some(&commit.tree()?), None)?;
    let stats = diff.stats()?;
    Ok((stats.insertions(), stats.deletions()))
}

fn collect_file_snapshots(
    repo: &Repository,
    tree: &Tree,
    idx: usize,
    files: &mut std::collections::HashMap<String, TrackedFile>,
) -> Result<()> {
    tree.walk(git2::TreeWalkMode::PreOrder, |dir, entry| {
        if entry.kind() == Some(git2::ObjectType::Blob) {
            process_blob_entry(repo, dir, entry, idx, files);
        }
        git2::TreeWalkResult::Ok
    })?;
    Ok(())
}

fn process_blob_entry(
    repo: &Repository,
    dir: &str,
    entry: &git2::TreeEntry,
    idx: usize,
    files: &mut std::collections::HashMap<String, TrackedFile>,
) {
    let path = format!("{}{}", dir, entry.name().unwrap_or(""));
    let Some(blob) = repo.find_blob(entry.id()).ok() else { return };
    let content = blob.content();
    #[allow(clippy::naive_bytecount)]
    let lines = content.iter().filter(|&&c| c == b'\n').count();
    files
        .entry(path.clone())
        .or_insert_with(|| TrackedFile::new(path))
        .history
        .insert(idx, FileSnapshot { lines, bytes: content.len() });
}

pub fn format_oid(oid: Oid) -> String {
    oid.to_string()[..8].to_string()
}

pub fn get_file_content(repo: &Repository, oid: Oid, path: &str) -> Result<String> {
    let commit = repo.find_commit(oid)?;
    let tree = commit.tree()?;
    let entry = tree.get_path(std::path::Path::new(path))?;
    let blob = repo.find_blob(entry.id())?;
    Ok(std::str::from_utf8(blob.content()).context("not UTF-8")?.to_string())
}

pub fn restore_file(repo: &Repository, oid: Oid, path: &str) -> Result<()> {
    let content = get_file_content(repo, oid, path)?;
    std::fs::write(path, content)?;
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/main.rs
use anyhow::{Context, Result};
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, MouseEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::{io, time::Duration};

mod app;
mod cli;
mod data;
mod git_ops;
mod mouse;
mod views;

use crate::{app::App, cli::Cli, mouse::hit_test, views::ViewMode};

fn main() -> Result<()> {
    let cli = Cli::parse_checked()?;

    if cli.dry_run {
        let _app = App::new(&cli).context("app init")?;
        println!("App initialized and rendered successfully");
        return Ok(());
    }

    let mut terminal = setup_terminal().context("terminal setup")?;
    let mut app = App::new(&cli).context("app init")?;

    let result = run_app(&mut terminal, &mut app);

    restore_terminal(&mut terminal)?;
    if let Some(msg) = &app.message {
        println!("{msg}");
    }
    result
}

fn run_app(terminal: &mut Terminal<CrosstermBackend<io::Stdout>>, app: &mut App) -> Result<()> {
    let mut hit_boxes = Vec::new();

    while !app.should_quit {
        terminal.draw(|f| {
            let result = views::draw(f, app);
            hit_boxes = result.hit_boxes;
        })?;

        if event::poll(Duration::from_millis(50))? {
            match event::read()? {
                Event::Key(key) => handle_key(app, key.code)?,
                Event::Mouse(mouse) => handle_mouse(app, mouse, &hit_boxes),
                _ => {}
            }
        }
    }
    Ok(())
}

fn view_from_key(code: KeyCode) -> Option<ViewMode> {
    match code {
        KeyCode::Char('1') => Some(ViewMode::Treemap),
        KeyCode::Char('2') => Some(ViewMode::Heatmap),
        KeyCode::Char('3') => Some(ViewMode::Minimap),
        KeyCode::Char('4') => Some(ViewMode::River),
        KeyCode::Char('5') => Some(ViewMode::Focus),
        _ => None,
    }
}

fn handle_navigation(app: &mut App, code: KeyCode) -> bool {
    match code {
        KeyCode::Left => { app.scroll_timeline(1); true }
        KeyCode::Right => { app.scroll_timeline(-1); true }
        KeyCode::Tab => { app.next_view(); true }
        KeyCode::BackTab => { app.prev_view(); true }
        _ => false,
    }
}

fn handle_key(app: &mut App, code: KeyCode) -> Result<()> {
    if let Some(mode) = view_from_key(code) {
        app.set_view(mode);
        return Ok(());
    }
    if handle_navigation(app, code) {
        return Ok(());
    }
    match code {
        KeyCode::Char('q' | 'Q') => app.should_quit = true,
        KeyCode::Char('r' | 'R') => app.restore_selected()?,
        KeyCode::Esc => app.selected_file = None,
        _ => {}
    }
    Ok(())
}

fn handle_mouse(app: &mut App, mouse: event::MouseEvent, hit_boxes: &[mouse::HitBox]) {
    app.mouse.update_position(mouse.column, mouse.row);

    match mouse.kind {
        MouseEventKind::Moved => {
            let hit = hit_test(mouse.column, mouse.row, hit_boxes);
            app.mouse.set_hover(hit);
        }
        MouseEventKind::Down(_) => {
            let hit = hit_test(mouse.column, mouse.row, hit_boxes);
            app.handle_click(hit);
        }
        MouseEventKind::ScrollUp => app.scroll_timeline(-1),
        MouseEventKind::ScrollDown => app.scroll_timeline(1),
        _ => {}
    }
}

fn setup_terminal() -> Result<Terminal<CrosstermBackend<io::Stdout>>> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    Ok(Terminal::new(CrosstermBackend::new(stdout))?)
}

fn restore_terminal(terminal: &mut Terminal<CrosstermBackend<io::Stdout>>) -> Result<()> {
    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
    terminal.show_cursor()?;
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/mouse.rs
use ratatui::layout::Rect;

#[derive(Clone, Debug)]
pub struct HitBox {
    pub rect: Rect,
    pub id: HitId,
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub enum HitId {
    File(String),
    ViewTab(usize),
    #[default]
    None,
}

#[derive(Default)]
pub struct MouseState {
    pub x: u16,
    pub y: u16,
    pub hover: HitId,
}

impl MouseState {
    pub fn update_position(&mut self, x: u16, y: u16) {
        self.x = x;
        self.y = y;
    }

    pub fn set_hover(&mut self, id: HitId) {
        self.hover = id;
    }
}

pub fn hit_test(x: u16, y: u16, boxes: &[HitBox]) -> HitId {
    for hb in boxes {
        let in_x = x >= hb.rect.x && x < hb.rect.x + hb.rect.width;
        let in_y = y >= hb.rect.y && y < hb.rect.y + hb.rect.height;
        if in_x && in_y {
            return hb.id.clone();
        }
    }
    HitId::None
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/views/mod.rs
pub mod treemap;

use ratatui::Frame;
use crate::{app::App, mouse::HitBox};

#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ViewMode {
    #[default]
    Treemap,
    Heatmap,
    Minimap,
    River,
    Focus,
}

impl ViewMode {
    pub const ALL: [ViewMode; 5] = [
        ViewMode::Treemap,
        ViewMode::Heatmap,
        ViewMode::Minimap,
        ViewMode::River,
        ViewMode::Focus,
    ];

    pub fn name(self) -> &'static str {
        match self {
            ViewMode::Treemap => "Treemap",
            ViewMode::Heatmap => "Heatmap",
            ViewMode::Minimap => "Minimap",
            ViewMode::River => "River",
            ViewMode::Focus => "Focus",
        }
    }

    pub fn index(self) -> usize {
        match self {
            ViewMode::Treemap => 0,
            ViewMode::Heatmap => 1,
            ViewMode::Minimap => 2,
            ViewMode::River => 3,
            ViewMode::Focus => 4,
        }
    }

    pub fn from_index(i: usize) -> Self {
        Self::ALL.get(i).copied().unwrap_or_default()
    }

    pub fn next(self) -> Self {
        Self::from_index((self.index() + 1) % Self::ALL.len())
    }

    pub fn prev(self) -> Self {
        let i = self.index();
        Self::from_index(if i == 0 { Self::ALL.len() - 1 } else { i - 1 })
    }
}

pub struct RenderResult {
    pub hit_boxes: Vec<HitBox>,
}

impl RenderResult {
    pub fn new() -> Self { Self { hit_boxes: Vec::new() } }
}

impl Default for RenderResult {
    fn default() -> Self { Self::new() }
}

pub fn draw(f: &mut Frame, app: &App) -> RenderResult {
    treemap::draw(f, app)
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/views/treemap.rs
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
    Frame,
};
use crate::{app::App, data::HealthStatus, mouse::{HitBox, HitId}, views::RenderResult};

const CLR_STABLE: Color = Color::Rgb(60, 60, 60);
const CLR_GREW: Color = Color::Rgb(80, 200, 120);
const CLR_SHRANK: Color = Color::Rgb(200, 200, 80);
const CLR_FUCKED: Color = Color::Rgb(255, 80, 80);
const CLR_NEW: Color = Color::Rgb(80, 180, 255);
const CLR_HOVER: Color = Color::Rgb(255, 0, 255);
const CLR_SELECTED: Color = Color::Rgb(0, 255, 255);

pub fn draw(f: &mut Frame, app: &App) -> RenderResult {
    let mut result = RenderResult::new();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Length(3),
            Constraint::Min(10),
            Constraint::Length(2),
        ])
        .split(f.area());

    draw_header(f, chunks[0], app, &mut result);
    draw_timeline(f, chunks[1], app);
    draw_treemap_area(f, chunks[2], app, &mut result);
    draw_status(f, chunks[3], app);
    result
}

fn draw_header(f: &mut Frame, area: Rect, app: &App, result: &mut RenderResult) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Min(20), Constraint::Length(60)])
        .split(area);

    let title = Paragraph::new(Line::from(vec![
        Span::styled("GIT-TREK ", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        Span::styled("v3.0", Style::default().fg(Color::DarkGray)),
    ])).block(Block::default().borders(Borders::BOTTOM));
    f.render_widget(title, chunks[0]);

    let tabs = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Ratio(1, 5); 5])
        .split(chunks[1]);

    for (i, mode) in crate::views::ViewMode::ALL.iter().enumerate() {
        let is_active = app.view == *mode;
        let is_hover = app.mouse.hover == HitId::ViewTab(i);
        let style = if is_active {
            Style::default().fg(Color::Black).bg(Color::Cyan)
        } else if is_hover {
            Style::default().fg(Color::Cyan)
        } else {
            Style::default().fg(Color::DarkGray)
        };
        let tab = Paragraph::new(format!("[{}] {}", i + 1, mode.name())).style(style);
        f.render_widget(tab, tabs[i]);
        result.hit_boxes.push(HitBox { rect: tabs[i], id: HitId::ViewTab(i) });
    }
}

fn draw_timeline(f: &mut Frame, area: Rect, app: &App) {
    let total = app.data.commits.len();
    let commit_info = app.data.commits.get(app.commit_idx);
    let title = match commit_info {
        Some(c) => format!(" {} / {} â”‚ {} ", app.commit_idx + 1, total, c.summary.chars().take(40).collect::<String>()),
        None => " Timeline ".to_string(),
    };
    
    let block = Block::default().borders(Borders::ALL).title(title);
    let inner = block.inner(area);
    f.render_widget(block, area);

    if total == 0 { return; }
    
    let width = inner.width as usize;
    if width == 0 { return; }
    
    let marker_pos = if total <= 1 {
        width / 2
    } else {
        (app.commit_idx * width.saturating_sub(1)) / total.saturating_sub(1)
    };
    
    let line: String = (0..width)
        .map(|i| if i == marker_pos { 'â—‰' } else { 'â”€' })
        .collect();
    
    let p = Paragraph::new(Span::styled(line, Style::default().fg(Color::Cyan)));
    f.render_widget(p, inner);
}

fn draw_treemap_area(f: &mut Frame, area: Rect, app: &App, result: &mut RenderResult) {
    let block = Block::default().borders(Borders::ALL).title(format!(" Files @ {} ", app.current_commit_label()));
    let inner = block.inner(area);
    f.render_widget(block, area);

    let files = app.files_at_current_commit();
    if files.is_empty() { return; }

    let rects = compute_treemap_layout(&files, inner);
    for (path, lines, rect) in &rects {
        let health = app.file_health(path);
        let is_hover = app.mouse.hover == HitId::File(path.clone());
        let is_selected = app.selected_file.as_ref() == Some(path);
        let bg = if is_selected { CLR_SELECTED } else if is_hover { CLR_HOVER } else { health_color(health) };
        let name = truncate_path(path, rect.width as usize);
        let content = Paragraph::new(vec![Line::from(name), Line::from(format!("{lines} ln"))])
            .style(Style::default().bg(bg).fg(Color::Black))
            .block(Block::default().borders(Borders::ALL));
        f.render_widget(content, *rect);
        result.hit_boxes.push(HitBox { rect: *rect, id: HitId::File(path.clone()) });
    }
}

fn draw_status(f: &mut Frame, area: Rect, app: &App) {
    let status = match &app.selected_file {
        Some(path) => format!("Selected: {path} | [R]estore [Q]uit"),
        None => "[click] select | [scroll] time travel | [1-5] views | [Q]uit".to_string(),
    };
    f.render_widget(Paragraph::new(status).style(Style::default().fg(Color::DarkGray)), area);
}

fn health_color(status: HealthStatus) -> Color {
    match status {
        HealthStatus::Stable | HealthStatus::Deleted => CLR_STABLE,
        HealthStatus::Grew => CLR_GREW,
        HealthStatus::Shrank => CLR_SHRANK,
        HealthStatus::MaybeFucked => CLR_FUCKED,
        HealthStatus::New => CLR_NEW,
    }
}

fn truncate_path(path: &str, max: usize) -> String {
    if path.len() <= max { return path.to_string(); }
    path.rsplit('/').next().unwrap_or(path).chars().take(max.saturating_sub(2)).collect::<String>() + ".."
}

#[allow(clippy::cast_precision_loss, clippy::cast_possible_truncation, clippy::cast_sign_loss)]
fn compute_treemap_layout(files: &[(String, usize)], area: Rect) -> Vec<(String, usize, Rect)> {
    let total: usize = files.iter().map(|(_, s)| s).sum();
    if total == 0 || area.width < 2 || area.height < 2 { return vec![]; }

    let mut result = Vec::new();
    let mut remaining = area;

    for (path, lines) in files.iter().take(20) {
        if remaining.width < 3 || remaining.height < 2 { break; }
        let ratio = (*lines as f64) / (total as f64);
        let horizontal = remaining.width >= remaining.height;
        let rect = if horizontal {
            let w = (f64::from(remaining.width) * ratio).max(4.0).min(f64::from(remaining.width)) as u16;
            let r = Rect::new(remaining.x, remaining.y, w, remaining.height);
            remaining.x += w;
            remaining.width = remaining.width.saturating_sub(w);
            r
        } else {
            let h = (f64::from(remaining.height) * ratio).max(3.0).min(f64::from(remaining.height)) as u16;
            let r = Rect::new(remaining.x, remaining.y, remaining.width, h);
            remaining.y += h;
            remaining.height = remaining.height.saturating_sub(h);
            r
        };
        result.push((path.clone(), *lines, rect));
    }
    result
}
#__SLOPCHOP_END__#


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END CODEBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SLOPCHOP CONSTRAINTS:
â–¡ Files < 2000 tokens
â–¡ Complexity â‰¤ 8
â–¡ Nesting â‰¤ 3
â–¡ Args â‰¤ 5
â–¡ No .unwrap() or .expect()
â–¡ Use SlopChop Format (#__SLOPCHOP_FILE__# ...)
