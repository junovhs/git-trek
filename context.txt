#__SLOPCHOP_FILE__# slopchop.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = [
    "tests",
    "spec",
]
ignore_tokens_on = [
    "README.md",
    "lock",
]

[preferences]
theme = "Cyberpunk"
auto_copy = true
auto_format = false
auto_commit = false
commit_prefix = "AI: "
allow_dirty_git = false
system_bell = false
backup_retention = 5
progress_bars = true
require_plan = false

[commands]
check = [
    "cargo clippy --all-targets -- -D warnings -W clippy::pedantic",
    "cargo test",
]
fix = ["cargo fmt"]

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# Cargo.toml
[package]
name = "git-trek"
version = "2.2.0"
edition = "2021"
authors = ["Spencer Nunamaker <junovhs@gmail.com>"]
description = "ğŸš€ Navigate git history like it's 1989!"
homepage = "https://github.com/junovhs/git-trek"
repository = "https://github.com/junovhs/git-trek"
license = "MIT"
readme = "README.md"
keywords = ["git", "cli", "tui", "navigation", "history"]
categories = ["command-line-utilities", "development-tools"]

[[bin]]
name = "git-trek"
path = "src/main.rs"

[dependencies]
anyhow = "1.0"
clap = { version = "4.5", features = ["derive"] }
crossterm = "0.28"
git2 = "0.19"
ratatui = "0.29"
chrono = "0.4"

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.10"

[profile.release]
lto = true
codegen-units = 1
strip = true
opt-level = "z"

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# Makefile
.PHONY: help build install run test clean release

help: ## Show this help message
	@echo "ğŸš€ git-trek - Available commands:"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'

build: ## Build the project
	cargo build

install: ## Install git-trek locally
	./install.sh

run: ## Run git-trek
	cargo run

test: ## Run tests
	cargo test

clean: ## Clean build artifacts
	cargo clean

release: ## Build optimized release binary
	cargo build --release
	@echo "âœ… Release binary at: target/release/git-trek"
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# OBEY.md

    CODE_WITH_INTENT â€” Decision Trees (POT-Aligned)
    A) Writing Tree (use in order)

    START: Implement feature/fix

    [STEP 0: GUARDRAILS GATE]
    â”œâ”€ Control flow OK? â†’ no recursion; acyclic call graph
    â”œâ”€ Loops bounded? â†’ static bound OR counter+hard error
    â”œâ”€ Allocations disciplined? â†’ no post-init allocs in hot paths; budgets set
    â”œâ”€ Functions tight? â†’ â‰¤60 SLOC; single responsibility; name â‰¤3 words
    â”œâ”€ Assertions adequate? â†’ â‰¥2 side-effect-free checks/function (avg); failure â†’ recover/error
    â”œâ”€ Scope minimal? â†’ no hidden globals; prefer immutability
    â”œâ”€ Returns & params? â†’ every return checked; every input validated
    â”œâ”€ Metaprogramming minimal? â†’ no eval/codegen/obfuscating macros; â‰¤2 flags/component (justified)
    â”œâ”€ Indirect calls analyzable? â†’ static dispatch or fixed table set at init
    â””â”€ Tooling wall? â†’ 0 warnings; linters/types/static analysis clean
    IF ANY "NO" â†’ REDESIGN BEFORE CODING

    [STEP 1: CHOOSE APPROACH]
    â”œâ”€ Is a simple, obvious solution available?
    â”‚   â”œâ”€ YES â†’ Use it
    â”‚   â””â”€ NO  â†’ Write 1 sentence why simple fails
    â”‚           â”œâ”€ Weak reason â†’ Use simple anyway
    â”‚           â””â”€ Strong reason â†’ Proceed complex + keep that sentence near code
    â””â”€ Considering something clever? â†’ Justify or drop it

    [STEP 2: STRUCTURE]
    â”œâ”€ Can you name each function in â‰¤3 words, no "and"? 
    â”‚   â”œâ”€ YES â†’ keep
    â”‚   â””â”€ NO  â†’ split until true
    â”œâ”€ Bounds & budgets visible at the callsite?
    â”‚   â”œâ”€ YES
    â”‚   â””â”€ NO  â†’ add constants/guards (loop MAX, mem caps, concurrency caps)
    â””â”€ Add assertions for: pre, post, invariants (avg â‰¥2/function)

    [STEP 3: ERRORS]
    â”œâ”€ Can this operation fail?
    â”‚   â”œâ”€ YES â†’ choose path:
    â”‚   â”‚   â”œâ”€ Graceful degrade (log+code+context) 
    â”‚   â”‚   â””â”€ Hard fail (clear code+message+next steps)
    â”‚   â””â”€ NO  â†’ continue
    â””â”€ Any silent failure possible? â†’ forbid; make loud or degrade with logs

    [STEP 4: DETERMINISM]
    â”œâ”€ Time/random? â†’ inject clock/seed; fix seeds in tests
    â”œâ”€ Map/set iteration? â†’ sort keys first
    â””â”€ Concurrency essential?
        â”œâ”€ NO â†’ single thread/event loop
        â””â”€ YES â†’ single writer; explicit ordering; timeouts

    [STEP 5: INSTRUMENTATION]
    â”œâ”€ Critical path? â†’ add entry/exit + key-decision logs (flag-guarded)
    â”œâ”€ Can you debug from logs alone?
    â”‚   â”œâ”€ YES
    â”‚   â””â”€ NO  â†’ add structured fields now
    â””â”€ Log format â†’ {ts, level, rid, subsystem, action, code, msg, context}

    [STEP 6: INTERFACES]
    â”œâ”€ Must be public?
    â”‚   â”œâ”€ YES â†’ document contract; validate inputs; plan compatibility
    â”‚   â””â”€ NO  â†’ keep internal
    â””â”€ Can you expose less? â†’ do it

    B) Pre-Ship Gate (stop on any "NO")

    No recursion; all loops bounded

    No post-init allocs in hot paths; budgets enforced

    Functions â‰¤60 SLOC; names â‰¤3 words; single responsibility

    Avg â‰¥2 assertions/function; failures recover or exit loudly

    Minimal scope; no hidden globals/state

    Every return checked; every param validated

    No eval/obfuscating macros; â‰¤2 flags/component, justified

    Indirect calls analyzable (static/fixed)

    Build: 0 warnings; linters/type/static analyzers 0 findings

    Logs make failures diagnosable without a debugger

    IF ANY "NO" â†’ FIX, THEN RECHECK.

    C) Delivery Tree (how you send code)
    [DELIVER]
    â”œâ”€ Assess Change Scope:
    â”‚   â”œâ”€ IF the change is small and self-contained (a single function, struct, or contiguous block)...
    â”‚   â”‚   â””â”€ THEN deliver a SCOPED BLOCK.
    â”‚   â””â”€ ELSE (changes are large, spread across multiple functions, or >50% of the file is new)...
    â”‚       â””â”€ THEN deliver a WHOLE FILE.
    â”‚
    â”œâ”€ Format SCOPED BLOCK:
    â”‚   â”œâ”€ Must be clearly identified with a header comment specifying the file and scope.
    â”‚   â”‚   â””â”€ Example: // FILE: src-tauri/src/render/pipeline.rs | FUNCTION: create_render_pipeline
    â”‚   â””â”€ Provide the entire function or block, from its signature to its closing brace }.
    â”‚
    â”œâ”€ Format WHOLE FILE:
    â”‚   â””â”€ Must be clearly identified with a header comment specifying the full path.
    â”‚   â””â”€ Example: // FILE: src-tauri/src/render/pipeline.rs
    â”‚
    â”œâ”€ Provide git commit message:
    â”‚   â”œâ”€ WHEN: For any new file, modification, or logical changeset delivered.
    â”‚   â”œâ”€ FORMAT: type(scope): subject (Conventional Commit).
    â”‚   â””â”€ RULE: Subject must complete the phrase "If applied, this commit will..."
    â”‚
    â””â”€ Always attach:
        â”œâ”€ Diff note: Brief "what & why" of the change.
        â””â”€ Confidence: LOW / MED / HIGH.

    D) Debug Tree (when something breaks)
    [DEBUG]
    â”œâ”€ Confidence in root cause?
    â”‚   â”œâ”€ HIGH â†’ proceed to fix
    â”‚   â””â”€ <HIGH â†’ gather evidence
    â”œâ”€ Gather
    â”‚   â”œâ”€ Exact repro steps
    â”‚   â”œâ”€ Env details
    â”‚   â”œâ”€ Logs (structured)
    â”‚   â””â”€ Smallest failing case + save artifacts/paths
    â”œâ”€ Analyze logs
    â”‚   â”œâ”€ Clear failure point? â†’ proceed
    â”‚   â””â”€ Not clear â†’ add flag-guarded probes (entry/exit/decisions/fails/state)
    â”œâ”€ Fix
    â”‚   â”œâ”€ Address root cause (not just symptoms)
    â”‚   â”œâ”€ Add defenses/tests to prevent recurrence
    â”‚   â””â”€ State confidence + uncertainties
    â””â”€ Verify
        â”œâ”€ Reproduce on old; confirm fixed on new
        â””â”€ Check for new edge failures; document learnings

    E) Language Dials (quick branches)
    [RUST]
    â”œâ”€ Deny warnings + clippy -D warnings
    â”œâ”€ No unwrap/expect outside tests â†’ use ?
    â”œâ”€ Prefer static dispatch; preallocate; no loop heap churn
    â”œâ”€ Inject time/random via traits; fixed seeds in tests
    â”œâ”€ tracing for structured logs; avoid println! in libs
    â””â”€ Avoid unsafe; if needed, isolate in one audited module

    [TS/JS]
    â”œâ”€ TS --strict; ESLint errors-as-errors; no implicit any
    â”œâ”€ Ban eval/new Function/with; dynamic import only at init
    â”œâ”€ Await all Promises; forbid unhandled rejections; timeouts mandatory
    â”œâ”€ Sort keys before iteration; reuse arrays/objects in hot paths
    â””â”€ Node: JSON logs; Browser: build-time flags (no runtime eval)

    [PYTHON]
    â”œâ”€ mypy --strict; Ruff/Flake8 as errors; pytest required
    â”œâ”€ Ban eval/exec & metaclass tricks in core
    â”œâ”€ Typed exceptions; never bare except; include context
    â”œâ”€ Inject datetime/random; Random(seed) in tests
    â””â”€ Reuse buffers (bytearray/memoryview) in hot paths; async: timeouts+cancel

    [CSS]
    â”œâ”€ Deterministic tokens; no magic values
    â”œâ”€ No IDs; depth â‰¤3; no !important
    â”œâ”€ One responsibility per class (BEM-like)
    â”œâ”€ Layout via grid/flex; central breakpoint scale
    â””â”€ Size/perf budget; drop unused rules

    F) Mindset Pointers (keep the soul)

    Build simply â†’ justify any cleverness

    Build in pieces â†’ split until one job per unit

    Build to survive â†’ degrade or fail loudly; never silent

    Build to understand â†’ names > abbrevs; stable error codes

    Build to prove â†’ evidence first; state confidence

    Build lean interfaces â†’ public = promise

    Build to adapt â†’ few explicit flags; invisible redundancy

    If it feels complicated â†’ simplify again

    Instruction to AI: Follow the trees top-to-bottom. If any guardrail or pre-ship check fails, stop and redesignâ€”do not request exceptions.
    
    when we lint, we lint with: 
    cargo clippy --all-targets -- -D warnings -D clippy::pedantic
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# README.md
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—    â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•    â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â•‘
â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—     â•‘
â•‘  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—    â•‘
â•‘   â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•         â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•    â•‘
â•‘                                                               â•‘
â•‘         Navigate Git History Like SNES Save Files!            â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

> *"Captain's Log, Stardate 2025: Where we're going, we don't need `git log --graph`."*

<p align="center">
  <img src="assets/demo.gif" alt="git-trek demo" width="100%" />
</p>

**git-trek** is a card-based, retro-futuristic TUI that transforms your git history into a navigable deck of commits. Scrub through time with left/right navigation while your working directory updates in real-time, letting you see and test your code at any point in historyâ€”without the fear of breaking anything.

## ğŸ Installation

### Prerequisites

The only requirement is the **Rust toolchain**:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### Development (Recommended)

**Clone and run locally without touching your PATH:**

```bash
git clone https://github.com/junovhs/git-trek.git
cd git-trek
cargo run --release
```

This keeps everything isolated. No global installs, no PATH pollution. Perfect for hacking on git-trek or testing it out.

**To use from any directory**, create an alias in your shell config:

```bash
# Add to ~/.bashrc or ~/.zshrc
alias gt='/path/to/git-trek/target/release/git-trek'
```

### Production Install (When You're Ready to Ship)

**Only install globally when you're sure you want it permanently:**

```bash
cargo install --path .
```

This places the binary in `~/.cargo/bin/` and makes `git-trek` available everywhere.

**To uninstall:**

```bash
cargo uninstall git-trek
```

---

## ğŸ¯ Features

### ğŸƒ Card-Based Navigation
Navigate through commits like flipping through SNES save file cards. Three commits visible at once: previous, current (highlighted), and next. Use **left/right arrows** or **A/D** to scrub through time.

### âš¡ Real-Time File Scrubbing
Your working directory updates as you navigate (with smart debouncing). Watch your editor change in real-time as you explore different points in history. No git commands to memorizeâ€”just arrow keys.

### ğŸ›¡ï¸ Safe, Non-Destructive
Creates a hidden session branch to safely scrub through history. Your original branch stays untouched. Quit anytime with `Q` and you're instantly back to where you started.

### ğŸ¨ Psychedelic Sci-Fi UI
Vibrant magenta, cyan, and yellow colors on pure black. The interface feels like a retro space console from 1989. Because exploring git history should look *cool*.

### ğŸ“Š Detailed Commit Inspection
Press `Enter` on any card to see full commit details: message, author, timestamp, and diff statistics. All presented in a clean, structured layout.

### ğŸŒ³ Dirty Tree Handling
Got uncommitted changes? No problem. git-trek offers three choices:
- **Stash** - Temporarily save changes (restored on exit)
- **Continue** - Browse in read-only mode (no checkout allowed)
- **Quit** - Exit without changes

No more "working tree dirty" errors blocking you.

---

## ğŸ•¹ï¸ The Workflow

1. **Launch**: Run `cargo run --release` (or `git-trek` if installed)
2. **Browse**: Use **â† â†’** or **A D** to flip through commit cards
3. **Watch**: Your files update in your editor ~200ms after you stop navigating
4. **Inspect**: Press **Enter** to see full commit details
5. **Checkout**: Press **C** from detail view to permanently checkout a commit
6. **Exit**: Press **Q** anytime to return to your original branch

---

## âŒ¨ï¸ Controls

### Card View (Main)
| Key | Action |
|-----|--------|
| `â†` `â†’` or `A` `D` | Navigate left/right through commit cards |
| `Enter` | Open detail view for current card |
| `P` | Pin anchor (marks current position) |
| `Q` | Quit and restore original branch |
| `?` | Show help |

### Detail View
| Key | Action |
|-----|--------|
| `Esc` or `Q` | Back to card view |
| `C` | Checkout this commit (with confirmation) |
| `T` | Toggle diff view |
| `P` / `F` | Mark test pass/fail (manual) |

### Checkout Confirmation
| Key | Action |
|-----|--------|
| `Y` | Confirm checkout (detaches HEAD) |
| `N` or `Esc` | Cancel and return to detail view |

---

## ğŸš¨ Requirements

- Git repository
- Terminal with color support
- Rust toolchain (for building)

**Note:** git-trek handles dirty working trees gracefullyâ€”no need to commit or stash first.

---

## ğŸ› ï¸ Development

### Quick Start
```bash
git clone https://github.com/junovhs/git-trek.git
cd git-trek
cargo run
```

### Build Release Binary
```bash
cargo build --release
# Binary is at: target/release/git-trek
```

### Run Tests
```bash
cargo test
cargo clippy
```

### Advanced Options
```bash
git-trek --autostash      # Auto-stash uncommitted changes
git-trek --worktree       # Use separate worktree (faster on large repos)
git-trek --since 2024-01-01  # Only show commits after date
git-trek --author "name"  # Filter by author
```

---

## ğŸ® Pro Tips

- **Use `--release` for smooth navigation**: Debug builds make git operations slow
- **Run in large repos**: git-trek shines when you have hundreds of commits
- **Test different states**: Perfect for bisecting bugs or finding when features were added
- **Pin anchors**: Use `P` to mark important commits as you explore
- **Read-only mode**: Great for safely browsing history without checkout privileges

---

## ğŸ› Troubleshooting

### "Navigation feels laggy"
Use `cargo run --release` instead of `cargo run`. Debug builds are 10x slower.

### "Files aren't updating"
Files update ~200ms after you **stop** navigating (debounced). This prevents the multi-line jump bug while keeping the scrubbing feature.

### "I want to reset everything"
```bash
cargo clean
rm -rf target
cargo build --release
```

---

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# install.sh
#!/usr/bin/env bash

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                 ğŸš€ GIT-TREK INSTALLER ğŸš€                     â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Check for Rust
if ! command -v cargo &> /dev/null; then
    echo "âŒ Cargo not found! Please install Rust first:"
    echo "   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
    exit 1
fi

echo "âœ… Rust detected: $(rustc --version)"
echo ""

# Build
echo "ğŸ”¨ Building git-trek..."
cargo build --release

# Install
echo "ğŸ“¦ Installing to cargo bin directory..."
cargo install --path .

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                    âœ¨ INSTALLATION COMPLETE âœ¨                â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "ğŸ® Start trekking with: git-trek"
echo ""
echo "Pro tip: Add this alias to your shell config:"
echo "  alias gt='git-trek'"
echo ""
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/app.rs
// app.rs - COPY THIS ENTIRE FILE

use anyhow::{anyhow, Context, Result};
use chrono::{DateTime, NaiveDate, Utc};
use git2::{
    build::CheckoutBuilder, DiffOptions, Oid, Repository, ResetType, Sort,
    StatusOptions, Tree,
};
use std::{
    collections::HashMap,
    path::PathBuf,
    time::{Duration, Instant},
};

use crate::{cli::Cli, shell};

pub const EVENT_POLL_MS: u64 = 100;
pub const CHECKOUT_DEBOUNCE_MS: u64 = 200;
pub const VERSION: &str = "2.2";

#[derive(PartialEq, Eq, Copy, Clone, Debug)]
pub enum AppState {
    DirtyTreeWarning,
    Browsing,
    ViewingDetail,
    ConfirmingCheckout,
    ShowingHelp,
}

#[derive(Clone, Default)]
pub struct Detail {
    pub hash: String,
    pub author: String,
    pub date: String,
    pub message: String,
    pub insertions: usize,
    pub deletions: usize,
    pub test_ok: Option<bool>,
    pub test_ms: Option<u128>,
    pub manual: Option<bool>,
}

#[derive(Clone)]
pub struct Point {
    pub oid: Oid,
    pub summary: String,
}

#[allow(clippy::struct_excessive_bools)]
pub struct App {
    pub state: AppState,
    pub repo: Repository,
    pub repo_dir: PathBuf,
    pub commits: Vec<Point>,
    pub idx: usize,
    pub anchor: Option<usize>,
    pub original_branch: String,
    pub session_branch: Option<String>,
    pub autostash: bool,
    pub used_worktree: bool,
    pub worktree_dir: Option<PathBuf>,
    pub opts: Cli,
    pub detail: Detail,
    pub diff_full: bool,
    pub tests: HashMap<Oid, (Option<bool>, Option<u128>)>,
    pub marks: HashMap<Oid, bool>,
    pub should_quit: bool,
    pub final_message: Option<String>,
    pub read_only: bool,
    pub tree_was_dirty: bool,
    pub last_nav_time: Instant,
    pub pending_checkout: bool,
    pub last_checkout_idx: Option<usize>,
}

impl App {
    pub fn new(cli: Cli) -> Result<Self> {
        let mut cwd_repo = Repository::open_from_env().context("not a git repo")?;
        let since_ts = parse_since(cli.since.as_deref())?;
        
        let tree_is_dirty = check_if_dirty(&mut cwd_repo)?;
        let autostash_oid = if cli.autostash && tree_is_dirty {
            Some(do_autostash(&mut cwd_repo)?)
        } else {
            None
        };

        let (repo, repo_dir, worktree_dir, used_worktree) = if cli.worktree {
            let (dir, wt) = spawn_worktree()?;
            (wt, dir.clone(), Some(dir), true)
        } else {
            (cwd_repo, std::env::current_dir()?, None, false)
        };

        let (head_oid, branch) = head_info(&repo)?;
        let session_branch = if cli.worktree {
            None
        } else {
            Some(new_session(&repo, head_oid)?)
        };

        let commits = load_commits(&repo, &cli, since_ts)?;
        let idx = commits.iter().position(|c| c.oid == head_oid).unwrap_or(0);

        let initial_state = if tree_is_dirty && !cli.autostash {
            AppState::DirtyTreeWarning
        } else {
            AppState::Browsing
        };

        let mut app = Self {
            state: initial_state,
            repo,
            repo_dir,
            commits,
            idx,
            anchor: None,
            original_branch: branch,
            session_branch,
            autostash: autostash_oid.is_some(),
            used_worktree,
            worktree_dir,
            opts: cli,
            detail: Detail::default(),
            diff_full: false,
            tests: HashMap::new(),
            marks: HashMap::new(),
            should_quit: false,
            final_message: None,
            read_only: false,
            tree_was_dirty: tree_is_dirty,
            last_nav_time: Instant::now(),
            pending_checkout: false,
            last_checkout_idx: None,
        };
        
        app.refresh_view()?;
        app.update_checkout()?;
        app.last_checkout_idx = Some(idx);
        
        Ok(app)
    }

    pub fn move_sel(&mut self, delta: isize) -> Result<()> {
        let len = self.commits.len();
        if len == 0 { return Ok(()); }
        
        let new_idx = if delta < 0 {
            self.idx.saturating_sub(delta.unsigned_abs())
        } else {
            self.idx.saturating_add(delta.unsigned_abs())
        };
        
        self.idx = new_idx.clamp(0, len - 1);
        self.last_nav_time = Instant::now();
        self.pending_checkout = true;
        self.refresh_view()
    }
    
    pub fn maybe_do_pending_checkout(&mut self) -> Result<()> {
        if !self.pending_checkout {
            return Ok(());
        }
        
        let elapsed = self.last_nav_time.elapsed();
        if elapsed < Duration::from_millis(CHECKOUT_DEBOUNCE_MS) {
            return Ok(());
        }
        
        if self.last_checkout_idx == Some(self.idx) {
            self.pending_checkout = false;
            return Ok(());
        }
        
        self.update_checkout()?;
        self.last_checkout_idx = Some(self.idx);
        self.pending_checkout = false;
        
        Ok(())
    }

    pub fn pin_anchor(&mut self) {
        self.anchor = Some(self.idx);
    }

    pub fn mark_manual(&mut self, pass: bool) {
        let oid = self.commits[self.idx].oid;
        self.marks.insert(oid, pass);
        self.detail.manual = Some(pass);
    }

    pub fn checkout(&mut self) -> Result<()> {
        if self.read_only {
            return Ok(());
        }
        
        let oid = self.commits[self.idx].oid;
        self.cleanup()?;
        self.should_quit = true;
        
        let final_message = if self.used_worktree {
            format!("Now at {} (worktree).", format_oid(oid))
        } else {
            self.repo.set_head_detached(oid)?;
            self.repo.checkout_head(Some(CheckoutBuilder::new().force()))?;
            format!("Now at {}.\nTo return: git switch {}", format_oid(oid), self.original_branch)
        };
        
        self.final_message = Some(final_message);
        Ok(())
    }

    pub fn enter_detail(&mut self) { self.state = AppState::ViewingDetail; }
    pub fn exit_detail(&mut self) { self.state = AppState::Browsing; }
    pub fn enter_confirm(&mut self) { 
        if !self.read_only {
            self.state = AppState::ConfirmingCheckout;
        }
    }
    pub fn exit_confirm(&mut self) { self.state = AppState::ViewingDetail; }
    pub fn toggle_help(&mut self) {
        self.state = if self.state == AppState::ShowingHelp { 
            AppState::Browsing 
        } else { 
            AppState::ShowingHelp 
        };
    }
    pub fn stop(&mut self) -> Result<()> {
        self.cleanup()?;
        self.should_quit = true;
        self.final_message = Some("Returned to original timeline.".into());
        Ok(())
    }

    pub fn handle_dirty_stash(&mut self) -> Result<()> {
        let sig = self.repo.signature()?;
        self.repo.stash_save(&sig, "git-trek autostash", Some(git2::StashFlags::INCLUDE_UNTRACKED))?;
        self.autostash = true;
        self.tree_was_dirty = false;
        self.state = AppState::Browsing;
        Ok(())
    }

    pub fn handle_dirty_continue(&mut self) {
        self.read_only = true;
        self.state = AppState::Browsing;
    }

    pub fn handle_dirty_quit(&mut self) {
        self.should_quit = true;
        self.final_message = Some("Exited without changes.".into());
    }

    fn refresh_view(&mut self) -> Result<()> {
        if self.commits.is_empty() { return Ok(()); }
        self.load_detail()?;
        if self.opts.cmd.is_some() { self.run_cmd()?; }
        Ok(())
    }

    fn update_checkout(&self) -> Result<()> {
        let oid = self.commits[self.idx].oid;
        let commit = self.repo.find_commit(oid)?;
        self.repo.reset(commit.as_object(), ResetType::Hard, None)?;
        Ok(())
    }

    fn run_cmd(&mut self) -> Result<()> {
        let oid = self.commits[self.idx].oid;
        
        if let Some((ok, ms)) = self.tests.get(&oid).copied() {
            self.detail.test_ok = ok;
            self.detail.test_ms = ms;
            return Ok(());
        }
        
        let Some(cmd) = self.opts.cmd.clone() else {
            return Ok(());
        };
        let timeout = (self.opts.cmd_timeout > 0)
            .then(|| Duration::from_secs(self.opts.cmd_timeout));
        
        let start = std::time::Instant::now();
        let ok = shell::run(&cmd, timeout, &self.repo_dir)?;
        let ms = start.elapsed().as_millis();
        
        self.tests.insert(oid, (Some(ok), Some(ms)));
        self.detail.test_ok = Some(ok);
        self.detail.test_ms = Some(ms);
        Ok(())
    }

    fn load_detail(&mut self) -> Result<()> {
        let oid = self.commits[self.idx].oid;
        let commit = self.repo.find_commit(oid)?;
        
        let parent_tree = if commit.parent_count() > 0 { 
            Some(commit.parent(0)?.tree()?) 
        } else { 
            None 
        };
        
        let diff = self.repo.diff_tree_to_tree(
            parent_tree.as_ref(), 
            Some(&commit.tree()?), 
            None
        )?;
        
        let stats = diff.stats()?;
        let ts = DateTime::<Utc>::from_timestamp(commit.time().seconds(), 0)
            .context("ts")?;
        
        let (ok, ms) = self.tests.get(&oid).copied().unwrap_or((None, None));
        let manual = self.marks.get(&oid).copied();

        self.detail = Detail {
            hash: format_oid(commit.id()),
            author: commit.author().to_string(),
            date: ts.to_rfc2822(),
            message: commit.message().unwrap_or("").to_string(),
            insertions: stats.insertions(),
            deletions: stats.deletions(),
            test_ok: ok,
            test_ms: ms,
            manual,
        };
        Ok(())
    }

    fn cleanup(&mut self) -> Result<()> {
        if let Some(name) = &self.session_branch {
            self.repo.set_head(&format!("refs/heads/{}", self.original_branch))?;
            self.repo.checkout_head(Some(CheckoutBuilder::new().force()))?;
            
            if let Ok(mut b) = self.repo.find_branch(name, git2::BranchType::Local) {
                let _ = b.delete();
            }
        }
        
        if self.autostash { 
            let _ = self.repo.stash_pop(0, None); 
        }
        
        if let Some(dir) = &self.worktree_dir {
            let _ = std::process::Command::new("git")
                .args(["worktree", "remove", "--force", &dir.to_string_lossy()])
                .status();
        }
        
        Ok(())
    }
}

pub fn format_oid(oid: Oid) -> String {
    oid.to_string()[..8].to_string()
}

pub fn format_summary(summary: &str) -> String {
    summary.chars().take(50).collect()
}

fn parse_since(since: Option<&str>) -> Result<Option<i64>> {
    let Some(s) = since else { return Ok(None) };
    let d = NaiveDate::parse_from_str(s, "%Y-%m-%d")
        .context("--since format")?;
    let ts = DateTime::<Utc>::from_naive_utc_and_offset(
        d.and_hms_opt(0, 0, 0).context("invalid time")?, 
        Utc
    ).timestamp();
    Ok(Some(ts))
}

fn check_if_dirty(repo: &mut Repository) -> Result<bool> {
    let mut so = StatusOptions::new();
    so.include_untracked(true).recurse_untracked_dirs(true);
    let dirty = !repo.statuses(Some(&mut so))?.is_empty();
    Ok(dirty)
}

fn do_autostash(repo: &mut Repository) -> Result<Oid> {
    let sig = repo.signature()?;
    let oid = repo.stash_save(
        &sig, 
        "git-trek autostash", 
        Some(git2::StashFlags::INCLUDE_UNTRACKED)
    )?;
    Ok(oid)
}

fn spawn_worktree() -> Result<(PathBuf, Repository)> {
    let dir = std::env::current_dir()?.join(".git-trek-worktree");
    let ok = std::process::Command::new("git")
        .args(["worktree", "add", "--force", "--detach", &dir.to_string_lossy(), "HEAD"])
        .status()?
        .success();
    
    if !ok { 
        return Err(anyhow!("git worktree add failed")); 
    }
    
    let wt = Repository::open(&dir)?;
    Ok((dir, wt))
}

fn head_info(repo: &Repository) -> Result<(Oid, String)> {
    let head = repo.head()?;
    let oid = head.target().context("no HEAD target")?;
    let name = head.shorthand().unwrap_or("HEAD").to_string();
    Ok((oid, name))
}

fn new_session(repo: &Repository, head: Oid) -> Result<String> {
    let name = format!(
        "_trek_session_{}", 
        std::time::UNIX_EPOCH.elapsed()?.as_millis()
    );
    let commit = repo.find_commit(head)?;
    repo.branch(&name, &commit, true)?;
    repo.set_head(&format!("refs/heads/{name}"))?;
    Ok(name)
}

fn load_commits(repo: &Repository, cli: &Cli, since_ts: Option<i64>) -> Result<Vec<Point>> {
    let mut revwalk = repo.revwalk()?;
    
    if cli.all { 
        revwalk.push_glob("refs/*")?; 
    } else { 
        revwalk.push_head()?; 
    }
    
    revwalk.set_sorting(Sort::TOPOLOGICAL)?;
    
    let mut commits = Vec::with_capacity(cli.limit);
    for id in revwalk {
        let oid = id?;
        let commit = repo.find_commit(oid)?;
        
        if let Some(ts) = since_ts { 
            if commit.time().seconds() < ts { 
                continue; 
            } 
        }
        
        if let Some(author) = &cli.author { 
            if !commit.author().to_string().to_lowercase()
                .contains(&author.to_lowercase()) { 
                continue; 
            } 
        }
        
        if let Some(path) = &cli.path { 
            if !touches_path(repo, oid, path)? { 
                continue; 
            } 
        }
        
        let summary = format_summary(commit.summary().unwrap_or(""));
        commits.push(Point { oid, summary });
        
        if commits.len() >= cli.limit { 
            break; 
        }
    }
    Ok(commits)
}

fn touches_path(repo: &Repository, oid: Oid, path: &str) -> Result<bool> {
    let commit = repo.find_commit(oid)?;
    let tree = commit.tree()?;
    
    let parent_tree: Option<Tree> = if commit.parent_count() > 0 { 
        Some(commit.parent(0)?.tree()?) 
    } else { 
        None 
    };
    
    let mut opts = DiffOptions::new();
    opts.pathspec(path);
    
    let diff = repo.diff_tree_to_tree(
        parent_tree.as_ref(), 
        Some(&tree), 
        Some(&mut opts)
    )?;
    
    Ok(diff.stats()?.files_changed() > 0)
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/cli.rs
use anyhow::{anyhow, Result};
use clap::Parser;

#[derive(Parser, Debug, Clone)]
#[command(name = "git-trek", about = "Navigate git history like it's 1989", version)]
pub struct Cli {
    /// Walk all refs, not just HEAD ancestry
    #[arg(long)]
    pub all: bool,

    /// Max commits to load
    #[arg(long, default_value_t = 200)]
    pub limit: usize,

    /// YYYY-MM-DD (include commits since date)
    #[arg(long)]
    pub since: Option<String>,

    /// Filter by author substring
    #[arg(long)]
    pub author: Option<String>,

    /// Only commits that touch this path
    #[arg(long)]
    pub path: Option<String>,

    /// Run command at each selection (e.g. `cargo test -q`)
    #[arg(long)]
    pub cmd: Option<String>,

    /// Timeout for --cmd (seconds). 0 = unlimited
    #[arg(long, default_value_t = 0)]
    pub cmd_timeout: u64,

    /// Stash changes on start; pop on exit
    #[arg(long)]
    pub autostash: bool,

    /// Use a temporary git worktree for navigation
    #[arg(long)]
    pub worktree: bool,

    /// Test mode: initialize app and exit (hidden)
    #[arg(long, hide = true)]
    pub dry_run: bool,
}

impl Cli {
    pub fn parse_checked() -> Result<Self> {
        let me = <Cli as Parser>::parse();
        if me.limit == 0 { return Err(anyhow!("--limit must be > 0")); }
        if let Some(s) = &me.since {
            chrono::NaiveDate::parse_from_str(s, "%Y-%m-%d")
                .map_err(|_| anyhow!("--since expects YYYY-MM-DD"))?;
        }
        Ok(me)
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/main.rs
// main.rs - COPY THIS ENTIRE FILE

use anyhow::{Context, Result};
use crossterm::{
    event::{self, Event, KeyCode, KeyEvent, KeyModifiers},
    execute,
    terminal::{
        disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen,
    },
};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::{
    io::{self, Stdout},
    time::Duration,
};

mod app;
mod cli;
mod shell;
mod ui;

use crate::{
    app::{App, AppState, EVENT_POLL_MS},
    cli::Cli,
};

fn main() -> Result<()> {
    let cli = Cli::parse_checked()?;

    if cli.dry_run {
        let app = App::new(cli).context("app setup")?;
        
        // Verify rendering doesn't panic
        let backend = ratatui::backend::TestBackend::new(80, 24);
        let mut terminal = Terminal::new(backend)?;
        terminal.draw(|f| ui::draw(f, &app)).context("dry-run render")?;
        
        println!("App initialized and rendered successfully");
        return Ok(());
    }

    let mut terminal = setup_terminal().context("terminal setup")?;
    let mut app = App::new(cli).context("app setup")?;
    
    let res = run_app(&mut terminal, &mut app);
    
    restore_terminal(&mut terminal).context("terminal restore")?;
    
    if let Some(msg) = app.final_message {
        println!("{msg}");
    }
    
    if let Err(e) = res {
        eprintln!("Error: {e:?}");
        return Err(e);
    }
    
    Ok(())
}

fn run_app(terminal: &mut Terminal<CrosstermBackend<Stdout>>, app: &mut App) -> Result<()> {
    while !app.should_quit {
        terminal.draw(|f| ui::draw(f, app))?;
        app.maybe_do_pending_checkout()?;
        
        if event::poll(Duration::from_millis(EVENT_POLL_MS))? {
            if let Event::Key(key_event) = event::read()? {
                if key_event.modifiers == KeyModifiers::NONE 
                    || key_event.modifiers == KeyModifiers::SHIFT {
                    handle_key(app, key_event)?;
                }
            }
        }
    }
    Ok(())
}

fn handle_key(app: &mut App, key_event: KeyEvent) -> Result<()> {
    let code = key_event.code;
    
    match app.state {
        AppState::DirtyTreeWarning => handle_dirty_warning(app, code)?,
        AppState::Browsing => handle_browsing(app, code)?,
        AppState::ViewingDetail => handle_detail(app, code),
        AppState::ConfirmingCheckout => handle_confirm(app, code)?,
        AppState::ShowingHelp => handle_help(app, code),
    }
    
    Ok(())
}

fn handle_dirty_warning(app: &mut App, code: KeyCode) -> Result<()> {
    match code {
        KeyCode::Char('s' | 'S') => app.handle_dirty_stash()?,
        KeyCode::Char('c' | 'C') => app.handle_dirty_continue(),
        KeyCode::Char('q' | 'Q') | KeyCode::Esc => app.handle_dirty_quit(),
        _ => {}
    }
    Ok(())
}

fn handle_browsing(app: &mut App, code: KeyCode) -> Result<()> {
    match code {
        KeyCode::Char('q' | 'Q') => app.stop()?,
        KeyCode::Left | KeyCode::Char('a' | 'A') => app.move_sel(-1)?,
        KeyCode::Right | KeyCode::Char('d' | 'D') => app.move_sel(1)?,
        KeyCode::Enter => app.enter_detail(),
        KeyCode::Char('p' | 'P') => app.pin_anchor(),
        KeyCode::Char('?' | 'h' | 'H') => app.toggle_help(),
        _ => {}
    }
    Ok(())
}

fn handle_detail(app: &mut App, code: KeyCode) {
    match code {
        KeyCode::Esc | KeyCode::Backspace | KeyCode::Char('q' | 'Q') => app.exit_detail(),
        KeyCode::Enter | KeyCode::Char('c' | 'C') => {
            if !app.read_only {
                app.enter_confirm();
            }
        }
        KeyCode::Char('t' | 'T') => app.diff_full = !app.diff_full,
        KeyCode::Char('p' | 'P') => app.mark_manual(true),
        KeyCode::Char('f' | 'F') => app.mark_manual(false),
        KeyCode::Char('?' | 'h' | 'H') => app.toggle_help(),
        _ => {}
    }
}

fn handle_confirm(app: &mut App, code: KeyCode) -> Result<()> {
    match code {
        KeyCode::Char('y' | 'Y') => app.checkout()?,
        KeyCode::Char('n' | 'N') | KeyCode::Esc | KeyCode::Backspace => app.exit_confirm(),
        KeyCode::Char('?' | 'h' | 'H') => app.toggle_help(),
        _ => {}
    }
    Ok(())
}

fn handle_help(app: &mut App, code: KeyCode) {
    match code {
        KeyCode::Esc | KeyCode::Backspace | 
        KeyCode::Char('q' | 'Q' | '?' | 'h' | 'H') => app.toggle_help(),
        _ => {}
    }
}

fn setup_terminal() -> Result<Terminal<CrosstermBackend<Stdout>>> {
    let mut stdout = io::stdout();
    enable_raw_mode()?;
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let terminal = Terminal::new(backend)?;
    Ok(terminal)
}

fn restore_terminal(terminal: &mut Terminal<CrosstermBackend<Stdout>>) -> Result<()> {
    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/shell.rs
use anyhow::Result;
use std::{
    path::Path,
    process::{Command, Stdio},
    time::Duration,
};

pub fn run(cmdline: &str, timeout: Option<Duration>, cwd: &Path) -> Result<bool> {
    let mut command = if cfg!(windows) {
        let mut command_builder = Command::new("cmd");
        command_builder.args(["/C", cmdline]);
        command_builder
    } else {
        let mut command_builder = Command::new("sh");
        command_builder.arg("-c");
        command_builder.arg(cmdline);
        command_builder
    };
    command.stdout(Stdio::null()).stderr(Stdio::null());
    command.current_dir(cwd);

    if let Some(to) = timeout {
        let mut child = command.spawn()?;
        match child.try_wait() {
            Ok(Some(status)) => return Ok(status.success()),
            Ok(None) => {
                let start = std::time::Instant::now();
                while start.elapsed() < to {
                    std::thread::sleep(Duration::from_millis(100));
                    if let Some(status) = child.try_wait()? {
                        return Ok(status.success());
                    }
                }
                child.kill()?;
                return Ok(false);
            }
            Err(e) => return Err(e.into()),
        }
    }
    Ok(command.status()?.success())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/ui.rs
// ui.rs - COPY THIS ENTIRE FILE (SNES SAVE FILE AESTHETIC)

use crate::app::{format_oid, format_summary, App, AppState, VERSION};
use ratatui::{
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, BorderType, Clear, Paragraph, Wrap},
    Frame,
};

const COLOR_MAGENTA: Color = Color::Rgb(255, 0, 255);
const COLOR_CYAN: Color = Color::Rgb(0, 255, 255);
const COLOR_YELLOW: Color = Color::Rgb(255, 255, 0);
const COLOR_GREEN: Color = Color::Rgb(0, 255, 128);
const COLOR_ORANGE: Color = Color::Rgb(255, 128, 0);
const COLOR_PURPLE: Color = Color::Rgb(200, 100, 255);
const COLOR_BLUE: Color = Color::Rgb(100, 200, 255);
const COLOR_DIM: Color = Color::Rgb(60, 60, 60);
const COLOR_CARD_BG: Color = Color::Rgb(30, 30, 30);
const COLOR_BLACK: Color = Color::Black;
const COLOR_WHITE: Color = Color::White;

pub fn draw(f: &mut Frame, app: &App) {
    if app.state == AppState::DirtyTreeWarning {
        draw_snes_layout(f, f.area(), app);
        draw_dirty_warning_modal(f, f.area());
        return;
    }

    if app.state == AppState::ConfirmingCheckout {
        draw_snes_layout(f, f.area(), app);
        draw_confirm_modal(f, f.area(), app);
        return;
    }

    if app.state == AppState::ShowingHelp {
        draw_snes_layout(f, f.area(), app);
        draw_help_modal(f, f.area());
        return;
    }

    if app.state == AppState::ViewingDetail {
        draw_snes_layout_with_detail(f, f.area(), app);
    } else {
        draw_snes_layout(f, f.area(), app);
    }
}

fn draw_snes_layout(f: &mut Frame, area: Rect, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),      // Title bar
            Constraint::Min(0),         // Cards
            Constraint::Length(5),      // Control hints
            Constraint::Length(3),      // Status bar
        ])
        .split(area);

    draw_title_bar(f, chunks[0]);
    draw_card_row(f, chunks[1], app);
    draw_control_hints(f, chunks[2], app);
    draw_status_bar(f, chunks[3], app);
}

fn draw_snes_layout_with_detail(f: &mut Frame, area: Rect, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Percentage(50),
            Constraint::Percentage(42),
            Constraint::Length(5),
        ])
        .split(area);

    draw_title_bar(f, chunks[0]);
    draw_card_row(f, chunks[1], app);
    draw_detail_panel(f, chunks[2], app);
    draw_control_hints(f, chunks[3], app);
}

fn draw_title_bar(f: &mut Frame, area: Rect) {
    let title = vec![Line::from(vec![Span::styled(
        "  â•â•â• GIT TREK - A Journey Through Time â•â•â•  ",
        Style::default()
            .fg(COLOR_CYAN)
            .add_modifier(Modifier::BOLD),
    )])];

    let title_widget = Paragraph::new(title)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_BLUE))
                .border_type(BorderType::Double),
        );

    f.render_widget(title_widget, area);
}

fn draw_card_row(f: &mut Frame, area: Rect, app: &App) {
    if app.commits.is_empty() {
        return;
    }

    let margin = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(10),
            Constraint::Percentage(80),
            Constraint::Percentage(10),
        ])
        .split(area);

    let cards_area = margin[1];

    let cards_layout = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(30),
            Constraint::Percentage(40),
            Constraint::Percentage(30),
        ])
        .split(cards_area);

    let current_idx = app.idx;

    // LEFT CARD (dimmed)
    if current_idx > 0 {
        let left_idx = current_idx - 1;
        draw_save_card(f, cards_layout[0], app, left_idx, CardState::Left);
    }

    // CENTER CARD (selected, glowing)
    draw_save_card(f, cards_layout[1], app, current_idx, CardState::Selected);

    // RIGHT CARD (dimmed)
    if current_idx < app.commits.len() - 1 {
        let right_idx = current_idx + 1;
        draw_save_card(f, cards_layout[2], app, right_idx, CardState::Right);
    }
}

#[derive(PartialEq, Eq, Clone, Copy)]
enum CardState {
    Left,
    Selected,
    Right,
}

fn draw_save_card(f: &mut Frame, area: Rect, app: &App, idx: usize, state: CardState) {
    let commit = &app.commits[idx];
    let oid_str = format_oid(commit.oid);
    let summary = format_summary(&commit.summary);

    let (border_color, border_type, bg_color, title_color, is_bright) = match state {
        CardState::Selected => (
            COLOR_MAGENTA,
            BorderType::Double,
            COLOR_CARD_BG,
            COLOR_CYAN,
            true,
        ),
        _ => (COLOR_DIM, BorderType::Plain, COLOR_BLACK, COLOR_DIM, false),
    };

    let marker = if app.anchor == Some(idx) { "âš¡" } else { "" };

    // Generate Braille art pattern based on commit hash
    let art = generate_braille_art(&oid_str, is_bright);

    let mut card_lines = vec![
        Line::from(""),
        Line::from(vec![Span::styled(
            format!("COMMIT {}", oid_str.to_uppercase()),
            Style::default()
                .fg(title_color)
                .add_modifier(Modifier::BOLD),
        )]),
        Line::from(""),
    ];

    // Add Braille art
    for art_line in art {
        card_lines.push(art_line);
    }

    card_lines.push(Line::from(""));
    card_lines.push(Line::from(""));

    // Add marker and summary
    card_lines.push(Line::from(vec![
        Span::styled(marker, Style::default().fg(COLOR_YELLOW)),
        Span::raw(" "),
        Span::styled(
            summary,
            Style::default().fg(if is_bright {
                COLOR_WHITE
            } else {
                COLOR_DIM
            }),
        ),
    ]));

    let card = Paragraph::new(card_lines)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(border_color).add_modifier(
                    if state == CardState::Selected {
                        Modifier::BOLD
                    } else {
                        Modifier::empty()
                    },
                ))
                .border_type(border_type)
                .style(Style::default().bg(bg_color)),
        )
        .alignment(Alignment::Center);

    f.render_widget(card, area);
}

fn generate_braille_art(seed: &str, bright: bool) -> Vec<Line<'static>> {
    // Generate deterministic Braille pattern based on commit hash
    let hash_bytes: Vec<u8> = seed.bytes().collect();

    let patterns = if bright {
        // Brighter, more complex patterns for selected card
        vec![
            "â ¿â¢¿â£¿â¡¿â ¿â¢¿â£¿â¡¿",
            "â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿",
            "â ›â ›â ›â ›â ›â ›â ›â ›",
            "â£€â£€â£€â£€â£€â£€â£€â£€",
            "â¢¸â¢¸â¢¸â¢¸â¢¸â¢¸â¢¸â¢¸",
        ]
    } else {
        // Simpler patterns for side cards
        vec!["â ¿â ¿â ¿â ¿â ¿â ¿â ¿â ¿", "â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿", "â ›â ›â ›â ›â ›â ›â ›â ›"]
    };

    let color = if bright {
        match *hash_bytes.first().unwrap_or(&0) as usize % 5 {
            0 => COLOR_CYAN,
            1 => COLOR_MAGENTA,
            2 => COLOR_GREEN,
            3 => COLOR_YELLOW,
            _ => COLOR_BLUE,
        }
    } else {
        COLOR_DIM
    };

    let selected_pattern =
        patterns[(*hash_bytes.get(1).unwrap_or(&0) as usize) % patterns.len()];

    vec![
        Line::from(""),
        Line::from(vec![Span::styled(
            selected_pattern.to_string(),
            Style::default().fg(color),
        )]),
        Line::from(vec![Span::styled(
            selected_pattern.to_string(),
            Style::default().fg(color),
        )]),
        Line::from(vec![Span::styled(
            selected_pattern.to_string(),
            Style::default().fg(color),
        )]),
        Line::from(""),
    ]
}

fn draw_control_hints(f: &mut Frame, area: Rect, app: &App) {
    let hints = match app.state {
        AppState::Browsing => vec![
            Line::from(vec![
                Span::raw("Use "),
                Span::styled(
                    "[LEFT]",
                    Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
                ),
                Span::raw(" "),
                Span::styled(
                    "[RIGHT]",
                    Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
                ),
                Span::raw(" to Navigate, "),
                Span::styled(
                    "[A]",
                    Style::default()
                        .fg(COLOR_YELLOW)
                        .add_modifier(Modifier::BOLD),
                ),
                Span::raw(" to Inspect, "),
                Span::styled(
                    "[Q]",
                    Style::default()
                        .fg(COLOR_ORANGE)
                        .add_modifier(Modifier::BOLD),
                ),
                Span::raw(" to Go Back"),
            ]),
            Line::from(""),
            Line::from(vec![
                Span::styled("    [P]", Style::default().fg(COLOR_PURPLE)),
                Span::raw(" Pin Anchor  "),
                Span::styled("[?]", Style::default().fg(COLOR_GREEN)),
                Span::raw(" Help"),
            ]),
        ],
        AppState::ViewingDetail => vec![Line::from(vec![
            Span::raw("Press "),
            Span::styled(
                "[ESC]",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::raw(" to Return, "),
            Span::styled(
                "[C]",
                Style::default()
                    .fg(COLOR_MAGENTA)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::raw(" to Checkout, "),
            Span::styled(
                "[T]",
                Style::default()
                    .fg(COLOR_YELLOW)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::raw(" to Toggle Diff"),
        ])],
        _ => vec![Line::from("")],
    };

    let hints_widget = Paragraph::new(hints)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_DIM)),
        );

    f.render_widget(hints_widget, area);
}

fn draw_status_bar(f: &mut Frame, area: Rect, app: &App) {
    let commit = &app.commits[app.idx];
    let oid_str = format_oid(commit.oid);
    let summary = &commit.summary;

    let status_text = vec![Line::from(vec![
        Span::styled("âš¡ ", Style::default().fg(COLOR_YELLOW)),
        Span::raw("Current Location: "),
        Span::styled(
            format!("COMMIT {} - {}", oid_str.to_uppercase(), summary),
            Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
        ),
    ])];

    let status_widget = Paragraph::new(status_text)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_BLUE)),
        );

    f.render_widget(status_widget, area);
}

fn draw_detail_panel(f: &mut Frame, area: Rect, app: &App) {
    let d = &app.detail;

    let h_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(50), Constraint::Percentage(50)])
        .split(area);

    let meta_lines = vec![
        Line::from(""),
        Line::from(vec![
            Span::styled(
                "HASH    Â» ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                &d.hash,
                Style::default()
                    .fg(COLOR_MAGENTA)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
        Line::from(vec![
            Span::styled(
                "AUTHOR  Â» ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(&d.author, Style::default().fg(COLOR_WHITE)),
        ]),
        Line::from(vec![
            Span::styled(
                "TIME    Â» ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(&d.date, Style::default().fg(COLOR_WHITE)),
        ]),
        Line::from(""),
        Line::from(vec![
            Span::styled(
                "CHANGES Â» ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                format!("+{} ", d.insertions),
                Style::default().fg(COLOR_GREEN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                format!("-{}", d.deletions),
                Style::default()
                    .fg(COLOR_ORANGE)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
    ];

    let meta_block = Paragraph::new(meta_lines).block(
        Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(COLOR_CYAN))
            .title(Span::styled(
                " INFO ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            )),
    );

    f.render_widget(meta_block, h_chunks[0]);

    let message_block = Paragraph::new(d.message.clone())
        .wrap(Wrap { trim: false })
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_PURPLE))
                .title(Span::styled(
                    " MESSAGE ",
                    Style::default()
                        .fg(COLOR_PURPLE)
                        .add_modifier(Modifier::BOLD),
                )),
        )
        .style(Style::default().fg(COLOR_WHITE));

    f.render_widget(message_block, h_chunks[1]);
}

fn draw_dirty_warning_modal(f: &mut Frame, area: Rect) {
    let modal_area = centered_rect(70, 50, area);
    f.render_widget(Clear, modal_area);

    let lines = vec![
        Line::from(""),
        Line::from(vec![
            Span::styled(
                "âš  ",
                Style::default()
                    .fg(COLOR_ORANGE)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                "WORKING TREE IS DIRTY",
                Style::default()
                    .fg(COLOR_ORANGE)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                " âš ",
                Style::default()
                    .fg(COLOR_ORANGE)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
        Line::from(""),
        Line::from(Span::styled(
            "You have uncommitted changes.",
            Style::default().fg(COLOR_WHITE),
        )),
        Line::from(""),
        Line::from(Span::styled(
            "Choose how to proceed:",
            Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
        Line::from(vec![Span::styled(
            "[S] STASH",
            Style::default().fg(COLOR_GREEN).add_modifier(Modifier::BOLD),
        )]),
        Line::from(vec![Span::raw("    Save changes temporarily")]),
        Line::from(""),
        Line::from(vec![Span::styled(
            "[C] CONTINUE",
            Style::default()
                .fg(COLOR_YELLOW)
                .add_modifier(Modifier::BOLD),
        )]),
        Line::from(vec![Span::raw("    Browse in read-only mode")]),
        Line::from(""),
        Line::from(vec![Span::styled(
            "[Q] QUIT",
            Style::default()
                .fg(COLOR_ORANGE)
                .add_modifier(Modifier::BOLD),
        )]),
        Line::from(vec![Span::raw("    Exit without changes")]),
    ];

    let paragraph = Paragraph::new(lines)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_ORANGE))
                .border_type(BorderType::Double)
                .title(Span::styled(
                    " âš  WARNING âš  ",
                    Style::default()
                        .fg(COLOR_ORANGE)
                        .add_modifier(Modifier::BOLD),
                )),
        );

    f.render_widget(paragraph, modal_area);
}

fn draw_confirm_modal(f: &mut Frame, area: Rect, app: &App) {
    let modal_area = centered_rect(60, 30, area);
    f.render_widget(Clear, modal_area);

    let p = &app.commits[app.idx];
    let oid_display = format_oid(p.oid);

    let lines = vec![
        Line::from(""),
        Line::from(vec![
            Span::styled(
                "âš  ",
                Style::default()
                    .fg(COLOR_YELLOW)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                "CHECKOUT COMMIT",
                Style::default()
                    .fg(COLOR_YELLOW)
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                " âš ",
                Style::default()
                    .fg(COLOR_YELLOW)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
        Line::from(""),
        Line::from(vec![
            Span::styled("Target: ", Style::default().fg(COLOR_CYAN)),
            Span::styled(
                oid_display,
                Style::default()
                    .fg(COLOR_MAGENTA)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
        Line::from(""),
        Line::from(Span::styled(
            "This will detach HEAD.",
            Style::default().fg(COLOR_WHITE),
        )),
        Line::from(""),
        Line::from(vec![
            Span::styled(
                "Proceed? ",
                Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
            ),
            Span::styled(
                "[Y/N]",
                Style::default()
                    .fg(COLOR_YELLOW)
                    .add_modifier(Modifier::BOLD),
            ),
        ]),
    ];

    let paragraph = Paragraph::new(lines)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_ORANGE))
                .border_type(BorderType::Double)
                .title(Span::styled(
                    " CONFIRM ",
                    Style::default()
                        .fg(COLOR_ORANGE)
                        .add_modifier(Modifier::BOLD),
                )),
        );

    f.render_widget(paragraph, modal_area);
}

fn draw_help_modal(f: &mut Frame, area: Rect) {
    let modal_area = centered_rect(70, 60, area);
    f.render_widget(Clear, modal_area);

    let help_text = vec![
        Line::from(""),
        Line::from(vec![Span::styled(
            "â•â•â• GIT TREK CONTROLS â•â•â•",
            Style::default().fg(COLOR_CYAN).add_modifier(Modifier::BOLD),
        )]),
        Line::from(""),
        Line::from(vec![Span::styled(
            "CARD NAVIGATION",
            Style::default()
                .fg(COLOR_YELLOW)
                .add_modifier(Modifier::UNDERLINED),
        )]),
        Line::from(""),
        Line::from(vec![
            Span::styled("  â† â†’, A D      ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Navigate cards"),
        ]),
        Line::from(vec![
            Span::styled("  ENTER         ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("View details"),
        ]),
        Line::from(vec![
            Span::styled("  P             ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Pin anchor"),
        ]),
        Line::from(vec![
            Span::styled("  Q             ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Quit"),
        ]),
        Line::from(""),
        Line::from(vec![Span::styled(
            "DETAIL VIEW",
            Style::default()
                .fg(COLOR_YELLOW)
                .add_modifier(Modifier::UNDERLINED),
        )]),
        Line::from(""),
        Line::from(vec![
            Span::styled("  ESC, Q        ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Back to cards"),
        ]),
        Line::from(vec![
            Span::styled("  C             ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Checkout"),
        ]),
        Line::from(vec![
            Span::styled("  T             ", Style::default().fg(COLOR_MAGENTA)),
            Span::raw("Toggle diff"),
        ]),
        Line::from(""),
        Line::from(vec![Span::styled(
            format!("git-trek v{VERSION}"),
            Style::default().fg(COLOR_DIM),
        )]),
    ];

    let paragraph = Paragraph::new(help_text)
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .border_style(Style::default().fg(COLOR_GREEN))
                .border_type(BorderType::Double)
                .title(Span::styled(
                    " HELP ",
                    Style::default().fg(COLOR_GREEN).add_modifier(Modifier::BOLD),
                )),
        );

    f.render_widget(paragraph, modal_area);
}

fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -> Rect {
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage((100 - percent_y) / 2),
            Constraint::Percentage(percent_y),
            Constraint::Percentage((100 - percent_y) / 2),
        ])
        .split(r);

    Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage((100 - percent_x) / 2),
            Constraint::Percentage(percent_x),
            Constraint::Percentage((100 - percent_x) / 2),
        ])
        .split(popup_layout[1])[1]
}
#__SLOPCHOP_END__#

